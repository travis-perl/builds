.\" Automatically generated by Pod::Man version 1.15
.\" Wed Aug  6 22:30:49 2014
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "ExtUtils::MM_Any 3"
.TH ExtUtils::MM_Any 3 "perl v5.6.2" "2014-04-29" "User Contributed Perl Documentation"
.UC
.SH "NAME"
ExtUtils::MM_Any \- Platform-agnostic \s-1MM\s0 methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  FOR INTERNAL USE ONLY!
.Ve
.Vb 1
\&  package ExtUtils::MM_SomeOS;
.Ve
.Vb 4
\&  # Temporarily, you have to subclass both.  Put MM_Any first.
\&  require ExtUtils::MM_Any;
\&  require ExtUtils::MM_Unix;
\&  @ISA = qw(ExtUtils::MM_Any ExtUtils::Unix);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1FOR\s0 \s-1INTERNAL\s0 \s-1USE\s0 \s-1ONLY\s0!\fR
.PP
ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of
modules.  It contains methods which are either inherently
cross-platform or are written in a cross-platform manner.
.PP
Subclass off of ExtUtils::MM_Any \fIand\fR ExtUtils::MM_Unix.  This is a
temporary solution.
.PP
\&\fB\s-1THIS\s0 \s-1MAY\s0 \s-1BE\s0 \s-1TEMPORARY\s0!\fR
.SH "METHODS"
.IX Header "METHODS"
Any methods marked \fIAbstract\fR must be implemented by subclasses.
.Sh "Cross-platform helper methods"
.IX Subsection "Cross-platform helper methods"
These are methods which help writing cross-platform code.
.PP
.I "os_flavor  \fIAbstract\fP"
.IX Subsection "os_flavor  Abstract"
.PP
.Vb 1
\&    my @os_flavor = $mm->os_flavor;
.Ve
@os_flavor is the style of operating system this is, usually
corresponding to the MM_*.pm file we're using.
.PP
The first element of \f(CW@os_flavor\fR is the major family (ie. Unix,
Windows, \s-1VMS\s0, \s-1OS/2\s0, etc...) and the rest are sub families.
.PP
Some examples:
.PP
.Vb 6
\&    Cygwin98       ('Unix',  'Cygwin', 'Cygwin9x')
\&    Windows        ('Win32')
\&    Win98          ('Win32', 'Win9x')
\&    Linux          ('Unix',  'Linux')
\&    MacOS X        ('Unix',  'Darwin', 'MacOS', 'MacOS X')
\&    OS/2           ('OS/2')
.Ve
This is used to write code for styles of operating system.
See \fIos_flavor_is()\fR for use.
.PP
.I "os_flavor_is"
.IX Subsection "os_flavor_is"
.PP
.Vb 2
\&    my $is_this_flavor = $mm->os_flavor_is($this_flavor);
\&    my $is_this_flavor = $mm->os_flavor_is(@one_of_these_flavors);
.Ve
Checks to see if the current operating system is one of the given flavors.
.PP
This is useful for code like:
.PP
.Vb 6
\&    if( $mm->os_flavor_is('Unix') ) {
\&        $out = `foo 2>&1`;
\&    }
\&    else {
\&        $out = `foo`;
\&    }
.Ve
.I "can_load_xs"
.IX Subsection "can_load_xs"
.PP
.Vb 1
\&    my $can_load_xs = $self->can_load_xs;
.Ve
Returns true if we have the ability to load \s-1XS\s0.
.PP
This is important because miniperl, used to build \s-1XS\s0 modules in the
core, can not load \s-1XS\s0.
.PP
.I "split_command"
.IX Subsection "split_command"
.PP
.Vb 1
\&    my @cmds = $MM->split_command($cmd, @args);
.Ve
Most \s-1OS\s0 have a maximum command length they can execute at once.  Large
modules can easily generate commands well past that limit.  Its
necessary to split long commands up into a series of shorter commands.
.PP
\&\f(CW\*(C`split_command\*(C'\fR will return a series of \f(CW@cmds\fR each processing part of
the args.  Collectively they will process all the arguments.  Each
individual line in \f(CW@cmds\fR will not be longer than the
\&\f(CW$self\fR->max_exec_len being careful to take into account macro expansion.
.PP
$cmd should include any switches and repeated initial arguments.
.PP
If no \f(CW@args\fR are given, no \f(CW@cmds\fR will be returned.
.PP
Pairs of arguments will always be preserved in a single command, this
is a heuristic for things like pm_to_blib and pod2man which work on
pairs of arguments.  This makes things like this safe:
.PP
.Vb 1
\&    $self->split_command($cmd, %pod2man);
.Ve
.I "echo"
.IX Subsection "echo"
.PP
.Vb 3
\&    my @commands = $MM->echo($text);
\&    my @commands = $MM->echo($text, $file);
\&    my @commands = $MM->echo($text, $file, \e%opts);
.Ve
Generates a set of \f(CW@commands\fR which print the \f(CW$text\fR to a \f(CW$file\fR.
.PP
If \f(CW$file\fR is not given, output goes to \s-1STDOUT\s0.
.PP
If \f(CW$opts\fR{append} is true the \f(CW$file\fR will be appended to rather than
overwritten.  Default is to overwrite.
.PP
If \f(CW$opts\fR{allow_variables} is true, make variables of the form
\&\f(CW\*(C`$(...)\*(C'\fR will not be escaped.  Other \f(CW\*(C`$\*(C'\fR will.  Default is to escape
all \f(CW\*(C`$\*(C'\fR.
.PP
Example of use:
.PP
.Vb 1
\&    my $make = map "\et$_\en", $MM->echo($text, $file);
.Ve
.I "wraplist"
.IX Subsection "wraplist"
.PP
.Vb 1
\&  my $args = $mm->wraplist(@list);
.Ve
Takes an array of items and turns them into a well-formatted list of
arguments.  In most cases this is simply something like:
.PP
.Vb 3
\&    FOO \e
\&    BAR \e
\&    BAZ
.Ve
.I "maketext_filter"
.IX Subsection "maketext_filter"
.PP
.Vb 1
\&    my $filter_make_text = $mm->maketext_filter($make_text);
.Ve
The text of the Makefile is run through this method before writing to
disk.  It allows systems a chance to make portability fixes to the
Makefile.
.PP
By default it does nothing.
.PP
This method is protected and not intended to be called outside of
MakeMaker.
.PP
.I "cd  \fIAbstract\fP"
.IX Subsection "cd  Abstract"
.PP
.Vb 1
\&  my $subdir_cmd = $MM->cd($subdir, @cmds);
.Ve
This will generate a make fragment which runs the \f(CW@cmds\fR in the given
\&\f(CW$dir\fR.  The rough equivalent to this, except cross platform.
.PP
.Vb 1
\&  cd $subdir && $cmd
.Ve
Currently \f(CW$dir\fR can only go down one level.  \*(L"foo\*(R" is fine.  \*(L"foo/bar\*(R" is
not.  \*(L"../foo\*(R" is right out.
.PP
The resulting \f(CW$subdir_cmd\fR has no leading tab nor trailing newline.  This
makes it easier to embed in a make string.  For example.
.PP
.Vb 6
\&      my $make = sprintf <<'CODE', $subdir_cmd;
\&  foo :
\&      $(ECHO) what
\&      %s
\&      $(ECHO) mouche
\&  CODE
.Ve
.I "oneliner  \fIAbstract\fP"
.IX Subsection "oneliner  Abstract"
.PP
.Vb 2
\&  my $oneliner = $MM->oneliner($perl_code);
\&  my $oneliner = $MM->oneliner($perl_code, \e@switches);
.Ve
This will generate a perl one-liner safe for the particular platform
you're on based on the given \f(CW$perl_code\fR and \f(CW@switches\fR (a \-e is
assumed) suitable for using in a make target.  It will use the proper
shell quoting and escapes.
.PP
$(\s-1PERLRUN\s0) will be used as perl.
.PP
Any newlines in \f(CW$perl_code\fR will be escaped.  Leading and trailing
newlines will be stripped.  Makes this idiom much easier:
.PP
.Vb 4
\&    my $code = $MM->oneliner(<<'CODE', [...switches...]);
\&some code here
\&another line here
\&CODE
.Ve
Usage might be something like:
.PP
.Vb 3
\&    # an echo emulation
\&    $oneliner = $MM->oneliner('print "Foo\en"');
\&    $make = '$oneliner > somefile';
.Ve
All dollar signs must be doubled in the \f(CW$perl_code\fR if you expect them
to be interpreted normally, otherwise it will be considered a make
macro.  Also remember to quote make macros else it might be used as a
bareword.  For example:
.PP
.Vb 2
\&    # Assign the value of the $(VERSION_FROM) make macro to $vf.
\&    $oneliner = $MM->oneliner('$$vf = "$(VERSION_FROM)"');
.Ve
Its currently very simple and may be expanded sometime in the figure
to include more flexible code and switches.
.PP
.I "quote_literal  \fIAbstract\fP"
.IX Subsection "quote_literal  Abstract"
.PP
.Vb 2
\&    my $safe_text = $MM->quote_literal($text);
\&    my $safe_text = $MM->quote_literal($text, \e%options);
.Ve
This will quote \f(CW$text\fR so it is interpreted literally in the shell.
.PP
For example, on Unix this would escape any single-quotes in \f(CW$text\fR and
put single-quotes around the whole thing.
.PP
If \f(CW$options\fR{allow_variables} is true it will leave \f(CW\*(C`'$(FOO)'\*(C'\fR make
variables untouched.  If false they will be escaped like any other
\&\f(CW\*(C`$\*(C'\fR.  Defaults to true.
.PP
.I "escape_dollarsigns"
.IX Subsection "escape_dollarsigns"
.PP
.Vb 1
\&    my $escaped_text = $MM->escape_dollarsigns($text);
.Ve
Escapes stray \f(CW\*(C`$\*(C'\fR so they are not interpreted as make variables.
.PP
It lets by \f(CW\*(C`$(...)\*(C'\fR.
.PP
.I "escape_all_dollarsigns"
.IX Subsection "escape_all_dollarsigns"
.PP
.Vb 1
\&    my $escaped_text = $MM->escape_all_dollarsigns($text);
.Ve
Escapes all \f(CW\*(C`$\*(C'\fR so they are not interpreted as make variables.
.PP
.I "escape_newlines  \fIAbstract\fP"
.IX Subsection "escape_newlines  Abstract"
.PP
.Vb 1
\&    my $escaped_text = $MM->escape_newlines($text);
.Ve
Shell escapes newlines in \f(CW$text\fR.
.PP
.I "max_exec_len  \fIAbstract\fP"
.IX Subsection "max_exec_len  Abstract"
.PP
.Vb 1
\&    my $max_exec_len = $MM->max_exec_len;
.Ve
Calculates the maximum command size the \s-1OS\s0 can exec.  Effectively,
this is the max size of a shell command line.
.PP
.I "make"
.IX Subsection "make"
.PP
.Vb 1
\&    my $make = $MM->make;
.Ve
Returns the make variant we're generating the Makefile for.  This attempts
to do some normalization on the information from \f(CW%Config\fR or the user.
.Sh "Targets"
.IX Subsection "Targets"
These are methods which produce make targets.
.PP
.I "all_target"
.IX Subsection "all_target"
.PP
Generate the default target 'all'.
.PP
.I "blibdirs_target"
.IX Subsection "blibdirs_target"
.PP
.Vb 1
\&    my $make_frag = $mm->blibdirs_target;
.Ve
Creates the blibdirs target which creates all the directories we use
in blib/.
.PP
The blibdirs.ts target is deprecated.  Depend on blibdirs instead.
.PP
.I "clean (o)"
.IX Subsection "clean (o)"
.PP
Defines the clean target.
.PP
.I "clean_subdirs_target"
.IX Subsection "clean_subdirs_target"
.PP
.Vb 1
\&  my $make_frag = $MM->clean_subdirs_target;
.Ve
Returns the clean_subdirs target.  This is used by the clean target to
call clean on any subdirectories which contain Makefiles.
.PP
.I "dir_target"
.IX Subsection "dir_target"
.PP
.Vb 1
\&    my $make_frag = $mm->dir_target(@directories);
.Ve
Generates targets to create the specified directories and set its
permission to \s-1PERM_DIR\s0.
.PP
Because depending on a directory to just ensure it exists doesn't work
too well (the modified time changes too often) \fIdir_target()\fR creates a
\&.exists file in the created directory.  It is this you should depend on.
For portability purposes you should use the $(\s-1DIRFILESEP\s0) macro rather
than a '/' to separate the directory from the file.
.PP
.Vb 1
\&    yourdirectory$(DIRFILESEP).exists
.Ve
.I "distdir"
.IX Subsection "distdir"
.PP
Defines the scratch directory target that will hold the distribution
before tar-ing (or shar-ing).
.PP
.I "dist_test"
.IX Subsection "dist_test"
.PP
Defines a target that produces the distribution in the
scratch directory, and runs 'perl Makefile.PL; make ;make test' in that
subdirectory.
.PP
.I "dynamic (o)"
.IX Subsection "dynamic (o)"
.PP
Defines the dynamic target.
.PP
.I "makemakerdflt_target"
.IX Subsection "makemakerdflt_target"
.PP
.Vb 1
\&  my $make_frag = $mm->makemakerdflt_target
.Ve
Returns a make fragment with the makemakerdeflt_target specified.
This target is the first target in the Makefile, is the default target
and simply points off to 'all' just in case any make variant gets
confused or something gets snuck in before the real 'all' target.
.PP
.I "manifypods_target"
.IX Subsection "manifypods_target"
.PP
.Vb 1
\&  my $manifypods_target = $self->manifypods_target;
.Ve
Generates the manifypods target.  This target generates man pages from
all \s-1POD\s0 files in \s-1MAN1PODS\s0 and \s-1MAN3PODS\s0.
.PP
.I "metafile_target"
.IX Subsection "metafile_target"
.PP
.Vb 1
\&    my $target = $mm->metafile_target;
.Ve
Generate the metafile target.
.PP
Writes the file \s-1META\s0.yml (\s-1YAML\s0 encoded meta-data) and \s-1META\s0.json
(\s-1JSON\s0 encoded meta-data) about the module in the distdir.
The format follows Module::Build's as closely as possible.
.PP
.I "metafile_data"
.IX Subsection "metafile_data"
.PP
.Vb 1
\&    my @metadata_pairs = $mm->metafile_data(\e%meta_add, \e%meta_merge);
.Ve
Returns the data which MakeMaker turns into the \s-1META\s0.yml file 
and the \s-1META\s0.json file.
.PP
Values of \f(CW%meta_add\fR will overwrite any existing metadata in those
keys.  \f(CW%meta_merge\fR will be merged with them.
.PP
.I "metafile_file"
.IX Subsection "metafile_file"
.PP
.Vb 1
\&    my $meta_yml = $mm->metafile_file(@metadata_pairs);
.Ve
Turns the \f(CW@metadata_pairs\fR into \s-1YAML\s0.
.PP
This method does not implement a complete \s-1YAML\s0 dumper, being limited
to dump a hash with values which are strings, undef's or nested hashes
and arrays of strings. No quoting/escaping is done.
.PP
.I "distmeta_target"
.IX Subsection "distmeta_target"
.PP
.Vb 1
\&    my $make_frag = $mm->distmeta_target;
.Ve
Generates the distmeta target to add \s-1META\s0.yml and \s-1META\s0.json to the \s-1MANIFEST\s0
in the distdir.
.PP
.I "mymeta"
.IX Subsection "mymeta"
.PP
.Vb 1
\&    my $mymeta = $mm->mymeta;
.Ve
Generate \s-1MYMETA\s0 information as a hash either from an existing \s-1CPAN\s0 Meta file
(\s-1META\s0.json or \s-1META\s0.yml) or from internal data.
.PP
.I "write_mymeta"
.IX Subsection "write_mymeta"
.PP
.Vb 1
\&    $self->write_mymeta( $mymeta );
.Ve
Write \s-1MYMETA\s0 information to \s-1MYMETA\s0.json and \s-1MYMETA\s0.yml.
.PP
.I "realclean (o)"
.IX Subsection "realclean (o)"
.PP
Defines the realclean target.
.PP
.I "realclean_subdirs_target"
.IX Subsection "realclean_subdirs_target"
.PP
.Vb 1
\&  my $make_frag = $MM->realclean_subdirs_target;
.Ve
Returns the realclean_subdirs target.  This is used by the realclean
target to call realclean on any subdirectories which contain Makefiles.
.PP
.I "signature_target"
.IX Subsection "signature_target"
.PP
.Vb 1
\&    my $target = $mm->signature_target;
.Ve
Generate the signature target.
.PP
Writes the file \s-1SIGNATURE\s0 with \*(L"cpansign \-s\*(R".
.PP
.I "distsignature_target"
.IX Subsection "distsignature_target"
.PP
.Vb 1
\&    my $make_frag = $mm->distsignature_target;
.Ve
Generates the distsignature target to add \s-1SIGNATURE\s0 to the \s-1MANIFEST\s0 in the
distdir.
.PP
.I "special_targets"
.IX Subsection "special_targets"
.PP
.Vb 1
\&  my $make_frag = $mm->special_targets
.Ve
Returns a make fragment containing any targets which have special
meaning to make.  For example, .SUFFIXES and .PHONY.
.Sh "Init methods"
.IX Subsection "Init methods"
Methods which help initialize the MakeMaker object and macros.
.PP
.I "init_ABSTRACT"
.IX Subsection "init_ABSTRACT"
.PP
.Vb 1
\&    $mm->init_ABSTRACT
.Ve
.I "init_INST"
.IX Subsection "init_INST"
.PP
.Vb 1
\&    $mm->init_INST;
.Ve
Called by init_main.  Sets up all INST_* variables except those related
to \s-1XS\s0 code.  Those are handled in init_xs.
.PP
.I "init_INSTALL"
.IX Subsection "init_INSTALL"
.PP
.Vb 1
\&    $mm->init_INSTALL;
.Ve
Called by init_main.  Sets up all INSTALL_* variables (except
\&\s-1INSTALLDIRS\s0) and *PREFIX.
.PP
.I "init_INSTALL_from_PREFIX"
.IX Subsection "init_INSTALL_from_PREFIX"
.PP
.Vb 1
\&  $mm->init_INSTALL_from_PREFIX;
.Ve
.I "init_from_INSTALL_BASE"
.IX Subsection "init_from_INSTALL_BASE"
.PP
.Vb 1
\&    $mm->init_from_INSTALL_BASE
.Ve
.I "init_VERSION  \fIAbstract\fP"
.IX Subsection "init_VERSION  Abstract"
.PP
.Vb 1
\&    $mm->init_VERSION
.Ve
Initialize macros representing versions of MakeMaker and other tools
.PP
\&\s-1MAKEMAKER:\s0 path to the MakeMaker module.
.PP
\&\s-1MM_VERSION:\s0 ExtUtils::MakeMaker Version
.PP
\&\s-1MM_REVISION:\s0 ExtUtils::MakeMaker version control revision (for backwards
             compat)
.PP
\&\s-1VERSION:\s0 version of your module
.PP
\&\s-1VERSION_MACRO:\s0 which macro represents the version (usually '\s-1VERSION\s0')
.PP
\&\s-1VERSION_SYM:\s0 like version but safe for use as an \s-1RCS\s0 revision number
.PP
\&\s-1DEFINE_VERSION:\s0 \-D line to set the module version when compiling
.PP
\&\s-1XS_VERSION:\s0 version in your .xs file.  Defaults to $(\s-1VERSION\s0)
.PP
\&\s-1XS_VERSION_MACRO:\s0 which macro represents the \s-1XS\s0 version.
.PP
\&\s-1XS_DEFINE_VERSION:\s0 \-D line to set the xs version when compiling.
.PP
Called by init_main.
.PP
.I "init_tools"
.IX Subsection "init_tools"
.PP
.Vb 1
\&    $MM->init_tools();
.Ve
Initializes the simple macro definitions used by \fItools_other()\fR and
places them in the \f(CW$MM\fR object.  These use conservative cross platform
versions and should be overridden with platform specific versions for
performance.
.PP
Defines at least these macros.
.PP
.Vb 1
\&  Macro             Description
.Ve
.Vb 2
\&  NOOP              Do nothing
\&  NOECHO            Tell make not to display the command itself
.Ve
.Vb 1
\&  SHELL             Program used to run shell commands
.Ve
.Vb 12
\&  ECHO              Print text adding a newline on the end
\&  RM_F              Remove a file
\&  RM_RF             Remove a directory
\&  TOUCH             Update a file's timestamp
\&  TEST_F            Test for a file's existence
\&  TEST_S            Test the size of a file
\&  CP                Copy a file
\&  CP_NONEMPTY       Copy a file if it is not empty
\&  MV                Move a file
\&  CHMOD             Change permissions on a file
\&  FALSE             Exit with non-zero
\&  TRUE              Exit with zero
.Ve
.Vb 2
\&  UMASK_NULL        Nullify umask
\&  DEV_NULL          Suppress all command output
.Ve
.I "init_others"
.IX Subsection "init_others"
.PP
.Vb 1
\&    $MM->init_others();
.Ve
Initializes the macro definitions having to do with compiling and
linking used by \fItools_other()\fR and places them in the \f(CW$MM\fR object.
.PP
If there is no description, its the same as the parameter to
\&\fIWriteMakefile()\fR documented in ExtUtils::MakeMaker.
.PP
.I "tools_other"
.IX Subsection "tools_other"
.PP
.Vb 1
\&    my $make_frag = $MM->tools_other;
.Ve
Returns a make fragment containing definitions for the macros \fIinit_others()\fR
initializes.
.PP
.I "init_DIRFILESEP  \fIAbstract\fP"
.IX Subsection "init_DIRFILESEP  Abstract"
.PP
.Vb 2
\&  $MM->init_DIRFILESEP;
\&  my $dirfilesep = $MM->{DIRFILESEP};
.Ve
Initializes the \s-1DIRFILESEP\s0 macro which is the separator between the
directory and filename in a filepath.  ie. / on Unix, \e on Win32 and
nothing on \s-1VMS\s0.
.PP
For example:
.PP
.Vb 2
\&    # instead of $(INST_ARCHAUTODIR)/extralibs.ld
\&    $(INST_ARCHAUTODIR)$(DIRFILESEP)extralibs.ld
.Ve
Something of a hack but it prevents a lot of code duplication between
MM_* variants.
.PP
Do not use this as a separator between directories.  Some operating
systems use different separators between subdirectories as between
directories and filenames (for example:  \s-1VOLUME\s0:[dir1.dir2]file on \s-1VMS\s0).
.PP
.I "init_linker  \fIAbstract\fP"
.IX Subsection "init_linker  Abstract"
.PP
.Vb 1
\&    $mm->init_linker;
.Ve
Initialize macros which have to do with linking.
.PP
\&\s-1PERL_ARCHIVE:\s0 path to libperl.a equivalent to be linked to dynamic
extensions.
.PP
\&\s-1PERL_ARCHIVE_AFTER:\s0 path to a library which should be put on the
linker command line \fIafter\fR the external libraries to be linked to
dynamic extensions.  This may be needed if the linker is one-pass, and
Perl includes some overrides for C \s-1RTL\s0 functions, such as \fImalloc()\fR.
.PP
\&\s-1EXPORT_LIST:\s0 name of a file that is passed to linker to define symbols
to be exported.
.PP
Some OSes do not need these in which case leave it blank.
.PP
.I "init_platform"
.IX Subsection "init_platform"
.PP
.Vb 1
\&    $mm->init_platform
.Ve
Initialize any macros which are for platform specific use only.
.PP
A typical one is the version number of your \s-1OS\s0 specific module.
(ie. MM_Unix_VERSION or \s-1MM_VMS_VERSION\s0).
.PP
.I "init_MAKE"
.IX Subsection "init_MAKE"
.PP
.Vb 1
\&    $mm->init_MAKE
.Ve
Initialize \s-1MAKE\s0 from either a \s-1MAKE\s0 environment variable or \f(CW$Config\fR{make}.
.Sh "Tools"
.IX Subsection "Tools"
A grab bag of methods to generate specific macros and commands.
.PP
.I "manifypods"
.IX Subsection "manifypods"
.PP
Defines targets and routines to translate the pods into manpages and
put them into the INST_* directories.
.PP
.I "POD2MAN_macro"
.IX Subsection "POD2MAN_macro"
.PP
.Vb 1
\&  my $pod2man_macro = $self->POD2MAN_macro
.Ve
Returns a definition for the \s-1POD2MAN\s0 macro.  This is a program
which emulates the pod2man utility.  You can add more switches to the
command by simply appending them on the macro.
.PP
Typical usage:
.PP
.Vb 1
\&    $(POD2MAN) --section=3 --perm_rw=$(PERM_RW) podfile1 man_page1 ...
.Ve
.I "test_via_harness"
.IX Subsection "test_via_harness"
.PP
.Vb 1
\&  my $command = $mm->test_via_harness($perl, $tests);
.Ve
Returns a \f(CW$command\fR line which runs the given set of \f(CW$tests\fR with
Test::Harness and the given \f(CW$perl\fR.
.PP
Used on the t/*.t files.
.PP
.I "test_via_script"
.IX Subsection "test_via_script"
.PP
.Vb 1
\&  my $command = $mm->test_via_script($perl, $script);
.Ve
Returns a \f(CW$command\fR line which just runs a single test without
Test::Harness.  No checks are done on the results, they're just
printed.
.PP
Used for test.pl, since they don't always follow Test::Harness
formatting.
.PP
.I "tool_autosplit"
.IX Subsection "tool_autosplit"
.PP
Defines a simple perl call that runs autosplit. May be deprecated by
pm_to_blib soon.
.PP
.I "arch_check"
.IX Subsection "arch_check"
.PP
.Vb 4
\&    my $arch_ok = $mm->arch_check(
\&        $INC{"Config.pm"},
\&        File::Spec->catfile($Config{archlibexp}, "Config.pm")
\&    );
.Ve
A sanity check that what Perl thinks the architecture is and what
Config thinks the architecture is are the same.  If they're not it
will return false and show a diagnostic message.
.PP
When building Perl it will always return true, as nothing is installed
yet.
.PP
The interface is a bit odd because this is the result of a
quick refactoring.  Don't rely on it.
.Sh "File::Spec wrappers"
.IX Subsection "File::Spec wrappers"
ExtUtils::MM_Any is a subclass of File::Spec.  The methods noted here
override File::Spec.
.PP
.I "catfile"
.IX Subsection "catfile"
.PP
File::Spec <= 0.83 has a bug where the file part of catfile is not
canonicalized.  This override fixes that bug.
.Sh "Misc"
.IX Subsection "Misc"
Methods I can't really figure out where they should go yet.
.PP
.I "find_tests"
.IX Subsection "find_tests"
.PP
.Vb 1
\&  my $test = $mm->find_tests;
.Ve
Returns a string suitable for feeding to the shell to return all
tests in t/*.t.
.PP
.I "find_tests_recursive"
.IX Subsection "find_tests_recursive"
.PP
.Vb 1
\&  my $tests = $mm->find_tests_recursive;
.Ve
Returns a string suitable for feeding to the shell to return all
tests in t/ but recursively.
.PP
.I "extra_clean_files"
.IX Subsection "extra_clean_files"
.PP
.Vb 1
\&    my @files_to_clean = $MM->extra_clean_files;
.Ve
Returns a list of \s-1OS\s0 specific files to be removed in the clean target in
addition to the usual set.
.PP
.I "installvars"
.IX Subsection "installvars"
.PP
.Vb 1
\&    my @installvars = $mm->installvars;
.Ve
A list of all the INSTALL* variables without the \s-1INSTALL\s0 prefix.  Useful
for iteration or building related variable sets.
.PP
.I "libscan"
.IX Subsection "libscan"
.PP
.Vb 1
\&  my $wanted = $self->libscan($path);
.Ve
Takes a path to a file or dir and returns an empty string if we don't
want to include this file in the library.  Otherwise it returns the
the \f(CW$path\fR unchanged.
.PP
Mainly used to exclude version control administrative directories from
installation.
.PP
.I "platform_constants"
.IX Subsection "platform_constants"
.PP
.Vb 1
\&    my $make_frag = $mm->platform_constants
.Ve
Returns a make fragment defining all the macros initialized in
\&\fIinit_platform()\fR rather than put them in \fIconstants()\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> and the denizens of
makemaker@perl.org with code from ExtUtils::MM_Unix and
ExtUtils::MM_Win32.
