.\" Automatically generated by Pod::Man version 1.15
.\" Thu Jan 22 04:16:53 2015
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "TAP::Parser 3"
.TH TAP::Parser 3 "perl v5.6.2" "2015-01-14" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1TAP:\s0:Parser \- Parse TAP output
.SH "VERSION"
.IX Header "VERSION"
Version 3.35
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser;
.Ve
.Vb 1
\&    my $parser = TAP::Parser->new( { source => $source } );
.Ve
.Vb 3
\&    while ( my $result = $parser->next ) {
\&        print $result->as_string;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser\*(C'\fR is designed to produce a proper parse of \s-1TAP\s0 output. For
an example of how to run tests through this module, see the simple
harnesses \f(CW\*(C`examples/\*(C'\fR.
.PP
There's a wiki dedicated to the Test Anything Protocol:
.PP
http://testanything.org
.PP
It includes the \s-1TAP:\s0:Parser Cookbook:
.PP
http://testanything.org/wiki/index.php/TAP::Parser_Cookbook
.SH "METHODS"
.IX Header "METHODS"
.Sh "Class Methods"
.IX Subsection "Class Methods"
.if n .I "\f(CW""new""\fP"
.el .I "\f(CWnew\fP"
.IX Subsection "new"
.PP
.Vb 1
\& my $parser = TAP::Parser->new(\e%args);
.Ve
Returns a new \f(CW\*(C`TAP::Parser\*(C'\fR object.
.PP
The arguments should be a hashref with \fIone\fR of the following keys:
.if n .Ip "\(bu \f(CW""""source""""\fR" 4
.el .Ip "\(bu \f(CWsource\fR" 4
.IX Item "source"
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
This is the preferred method of passing input to the constructor.
.Sp
The \f(CW\*(C`source\*(C'\fR is used to create a the TAP::Parser::Source manpage that is passed to the
the iterator_factory_class entry elsewhere in this document which in turn figures out how to handle the source and
creates a <\s-1TAP:\s0:Parser::Iterator> for it.  The iterator is used by the parser to
read in the \s-1TAP\s0 stream.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.if n .Ip "\(bu \f(CW""""tap""""\fR" 4
.el .Ip "\(bu \f(CWtap\fR" 4
.IX Item "tap"
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
The value should be the complete \s-1TAP\s0 output.
.Sp
The \fItap\fR is used to create a the TAP::Parser::Source manpage that is passed to the
the iterator_factory_class entry elsewhere in this document which in turn figures out how to handle the source and
creates a <\s-1TAP:\s0:Parser::Iterator> for it.  The iterator is used by the parser to
read in the \s-1TAP\s0 stream.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.if n .Ip "\(bu \f(CW""""exec""""\fR" 4
.el .Ip "\(bu \f(CWexec\fR" 4
.IX Item "exec"
Must be passed an array reference.
.Sp
The \fIexec\fR array ref is used to create a the TAP::Parser::Source manpage that is passed
to the the iterator_factory_class entry elsewhere in this document which in turn figures out how to handle the
source and creates a <\s-1TAP:\s0:Parser::Iterator> for it.  The iterator is used by
the parser to read in the \s-1TAP\s0 stream.
.Sp
By default the the TAP::Parser::SourceHandler::Executable manpage class will create a
the TAP::Parser::Iterator::Process manpage object to handle the source.  This passes the
array reference strings as command arguments to IPC::Open3::open3:
.Sp
.Vb 1
\& exec => [ '/usr/bin/ruby', 't/my_test.rb' ]
.Ve
If any \f(CW\*(C`test_args\*(C'\fR are given they will be appended to the end of the command
argument list.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.PP
The following keys are optional.
.if n .Ip "\(bu \f(CW""""sources""""\fR" 4
.el .Ip "\(bu \f(CWsources\fR" 4
.IX Item "sources"
\&\fI\s-1NEW\s0 to 3.18\fR.
.Sp
If set, \f(CW\*(C`sources\*(C'\fR must be a hashref containing the names of the
the TAP::Parser::SourceHandler manpages to load and/or configure.  The values are a
hash of configuration that will be accessible to the source handlers via
the config_for entry in the TAP::Parser::Source manpage.
.Sp
For example:
.Sp
.Vb 5
\&  sources => {
\&    Perl => { exec => '/path/to/custom/perl' },
\&    File => { extensions => [ '.tap', '.txt' ] },
\&    MyCustom => { some => 'config' },
\&  }
.Ve
This will cause \f(CW\*(C`TAP::Parser\*(C'\fR to pass custom configuration to two of the built-
in source handlers \- the TAP::Parser::SourceHandler::Perl manpage,
the TAP::Parser::SourceHandler::File manpage \- and attempt to load the \f(CW\*(C`MyCustom\*(C'\fR
class.  See the load_handlers entry in the TAP::Parser::IteratorFactory manpage for more detail.
.Sp
The \f(CW\*(C`sources\*(C'\fR parameter affects how \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR parameters
are handled.
.Sp
See the TAP::Parser::IteratorFactory manpage, the TAP::Parser::SourceHandler manpage and subclasses for
more details.
.if n .Ip "\(bu \f(CW""""callback""""\fR" 4
.el .Ip "\(bu \f(CWcallback\fR" 4
.IX Item "callback"
If present, each callback corresponding to a given result type will be called
with the result as the argument if the \f(CW\*(C`run\*(C'\fR method is used:
.Sp
.Vb 7
\& my %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
.Ve
.Vb 11
\& my $aggregator = TAP::Parser::Aggregator->new;
\& for my $file ( @test_files ) {
\&     my $parser = TAP::Parser->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser->run;
\&     $aggregator->add( $file, $parser );
\& }
.Ve
.if n .Ip "\(bu \f(CW""""switches""""\fR" 4
.el .Ip "\(bu \f(CWswitches\fR" 4
.IX Item "switches"
If using a Perl file as a source, optional switches may be passed which will
be used when invoking the perl executable.
.Sp
.Vb 4
\& my $parser = TAP::Parser->new( {
\&     source   => $test_file,
\&     switches => [ '-Ilib' ],
\& } );
.Ve
.if n .Ip "\(bu \f(CW""""test_args""""\fR" 4
.el .Ip "\(bu \f(CWtest_args\fR" 4
.IX Item "test_args"
Used in conjunction with the \f(CW\*(C`source\*(C'\fR and \f(CW\*(C`exec\*(C'\fR option to supply a reference
to an \f(CW\*(C`@ARGV\*(C'\fR style array of arguments to pass to the test program.
.if n .Ip "\(bu \f(CW""""spool""""\fR" 4
.el .Ip "\(bu \f(CWspool\fR" 4
.IX Item "spool"
If passed a filehandle will write a copy of all parsed \s-1TAP\s0 to that handle.
.if n .Ip "\(bu \f(CW""""merge""""\fR" 4
.el .Ip "\(bu \f(CWmerge\fR" 4
.IX Item "merge"
If false, \s-1STDERR\s0 is not captured (though it is 'relayed' to keep it
somewhat synchronized with \s-1STDOUT\s0.)
.Sp
If true, \s-1STDERR\s0 and \s-1STDOUT\s0 are the same filehandle.  This may cause
breakage if \s-1STDERR\s0 contains anything resembling \s-1TAP\s0 format, but does
allow exact synchronization.
.Sp
Subtleties of this behavior may be platform-dependent and may change in
the future.
.if n .Ip "\(bu \f(CW""""grammar_class""""\fR" 4
.el .Ip "\(bu \f(CWgrammar_class\fR" 4
.IX Item "grammar_class"
This option was introduced to let you easily customize which \fIgrammar\fR class
the parser should use.  It defaults to the TAP::Parser::Grammar manpage.
.Sp
See also the make_grammar entry elsewhere in this document.
.if n .Ip "\(bu \f(CW""""result_factory_class""""\fR" 4
.el .Ip "\(bu \f(CWresult_factory_class\fR" 4
.IX Item "result_factory_class"
This option was introduced to let you easily customize which \fIresult\fR
factory class the parser should use.  It defaults to
the TAP::Parser::ResultFactory manpage.
.Sp
See also the make_result entry elsewhere in this document.
.if n .Ip "\(bu \f(CW""""iterator_factory_class""""\fR" 4
.el .Ip "\(bu \f(CWiterator_factory_class\fR" 4
.IX Item "iterator_factory_class"
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
This option was introduced to let you easily customize which \fIiterator\fR
factory class the parser should use.  It defaults to
the TAP::Parser::IteratorFactory manpage.
.Sh "Instance Methods"
.IX Subsection "Instance Methods"
.if n .I "\f(CW""next""\fP"
.el .I "\f(CWnext\fP"
.IX Subsection "next"
.PP
.Vb 4
\&  my $parser = TAP::Parser->new( { source => $file } );
\&  while ( my $result = $parser->next ) {
\&      print $result->as_string, "\en";
\&  }
.Ve
This method returns the results of the parsing, one result at a time.  Note
that it is destructive.  You can't rewind and examine previous results.
.PP
If callbacks are used, they will be issued before this call returns.
.PP
Each result returned is a subclass of the TAP::Parser::Result manpage.  See that
module and related classes for more information on how to use them.
.PP
.if n .I "\f(CW""run""\fP"
.el .I "\f(CWrun\fP"
.IX Subsection "run"
.PP
.Vb 1
\&  $parser->run;
.Ve
This method merely runs the parser and parses all of the \s-1TAP\s0.
.PP
.if n .I "\f(CW""make_grammar""\fP"
.el .I "\f(CWmake_grammar\fP"
.IX Subsection "make_grammar"
.PP
Make a new the TAP::Parser::Grammar manpage object and return it.  Passes through any
arguments given.
.PP
The \f(CW\*(C`grammar_class\*(C'\fR can be customized, as described in the new entry elsewhere in this document.
.PP
.if n .I "\f(CW""make_result""\fP"
.el .I "\f(CWmake_result\fP"
.IX Subsection "make_result"
.PP
Make a new the TAP::Parser::Result manpage object using the parser's
the TAP::Parser::ResultFactory manpage, and return it.  Passes through any arguments
given.
.PP
The \f(CW\*(C`result_factory_class\*(C'\fR can be customized, as described in the new entry elsewhere in this document.
.PP
.if n .I "\f(CW""make_iterator_factory""\fP"
.el .I "\f(CWmake_iterator_factory\fP"
.IX Subsection "make_iterator_factory"
.PP
\&\fI\s-1NEW\s0 to 3.18\fR.
.PP
Make a new the TAP::Parser::IteratorFactory manpage object and return it.  Passes through
any arguments given.
.PP
\&\f(CW\*(C`iterator_factory_class\*(C'\fR can be customized, as described in the new entry elsewhere in this document.
.SH "INDIVIDUAL RESULTS"
.IX Header "INDIVIDUAL RESULTS"
If you've read this far in the docs, you've seen this:
.PP
.Vb 3
\&    while ( my $result = $parser->next ) {
\&        print $result->as_string;
\&    }
.Ve
Each result returned is a the TAP::Parser::Result manpage subclass, referred to as
\&\fIresult types\fR.
.Sh "Result types"
.IX Subsection "Result types"
Basically, you fetch individual results from the \s-1TAP\s0.  The six types, with
examples of each, are as follows:
.Ip "\(bu Version" 4
.IX Item "Version"
.Vb 1
\& TAP version 12
.Ve
.Ip "\(bu Plan" 4
.IX Item "Plan"
.Vb 1
\& 1..42
.Ve
.Ip "\(bu Pragma" 4
.IX Item "Pragma"
.Vb 1
\& pragma +strict
.Ve
.Ip "\(bu Test" 4
.IX Item "Test"
.Vb 1
\& ok 3 - We should start with some foobar!
.Ve
.Ip "\(bu Comment" 4
.IX Item "Comment"
.Vb 1
\& # Hope we don't use up the foobar.
.Ve
.Ip "\(bu Bailout" 4
.IX Item "Bailout"
.Vb 1
\& Bail out!  We ran out of foobar!
.Ve
.Ip "\(bu Unknown" 4
.IX Item "Unknown"
.Vb 1
\& ... yo, this ain't TAP! ...
.Ve
.PP
Each result fetched is a result object of a different type.  There are common
methods to each result object and different types may have methods unique to
their type.  Sometimes a type method may be overridden in a subclass, but its
use is guaranteed to be identical.
.Sh "Common type methods"
.IX Subsection "Common type methods"
.if n .I "\f(CW""type""\fP"
.el .I "\f(CWtype\fP"
.IX Subsection "type"
.PP
Returns the type of result, such as \f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`test\*(C'\fR.
.PP
.if n .I "\f(CW""as_string""\fP"
.el .I "\f(CWas_string\fP"
.IX Subsection "as_string"
.PP
Prints a string representation of the token.  This might not be the exact
output, however.  Tests will have test numbers added if not present, \s-1TODO\s0 and
\&\s-1SKIP\s0 directives will be capitalized and, in general, things will be cleaned
up.  If you need the original text for the token, see the \f(CW\*(C`raw\*(C'\fR method.
.PP
.if n .I "\f(CW""raw""\fP"
.el .I "\f(CWraw\fP"
.IX Subsection "raw"
.PP
Returns the original line of text which was parsed.
.PP
.if n .I "\f(CW""is_plan""\fP"
.el .I "\f(CWis_plan\fP"
.IX Subsection "is_plan"
.PP
Indicates whether or not this is the test plan line.
.PP
.if n .I "\f(CW""is_test""\fP"
.el .I "\f(CWis_test\fP"
.IX Subsection "is_test"
.PP
Indicates whether or not this is a test line.
.PP
.if n .I "\f(CW""is_comment""\fP"
.el .I "\f(CWis_comment\fP"
.IX Subsection "is_comment"
.PP
Indicates whether or not this is a comment. Comments will generally only
appear in the \s-1TAP\s0 stream if \s-1STDERR\s0 is merged to \s-1STDOUT\s0. See the
\&\f(CW\*(C`merge\*(C'\fR option.
.PP
.if n .I "\f(CW""is_bailout""\fP"
.el .I "\f(CWis_bailout\fP"
.IX Subsection "is_bailout"
.PP
Indicates whether or not this is bailout line.
.PP
.if n .I "\f(CW""is_yaml""\fP"
.el .I "\f(CWis_yaml\fP"
.IX Subsection "is_yaml"
.PP
Indicates whether or not the current item is a \s-1YAML\s0 block.
.PP
.if n .I "\f(CW""is_unknown""\fP"
.el .I "\f(CWis_unknown\fP"
.IX Subsection "is_unknown"
.PP
Indicates whether or not the current line could be parsed.
.PP
.if n .I "\f(CW""is_ok""\fP"
.el .I "\f(CWis_ok\fP"
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result->is_ok ) { ... }
.Ve
Reports whether or not a given result has passed.  Anything which is \fBnot\fR a
test result returns true.  This is merely provided as a convenient shortcut
which allows you to do this:
.PP
.Vb 5
\& my $parser = TAP::Parser->new( { source => $source } );
\& while ( my $result = $parser->next ) {
\&     # only print failing results
\&     print $result->as_string unless $result->is_ok;
\& }
.Ve
.if n .Sh "\f(CW""plan""\fP methods"
.el .Sh "\f(CWplan\fP methods"
.IX Subsection "plan methods"
.Vb 1
\& if ( $result->is_plan ) { ... }
.Ve
If the above evaluates as true, the following methods will be available on the
\&\f(CW\*(C`$result\*(C'\fR object.
.PP
.if n .I "\f(CW""plan""\fP"
.el .I "\f(CWplan\fP"
.IX Subsection "plan"
.PP
.Vb 3
\&  if ( $result->is_plan ) {
\&     print $result->plan;
\&  }
.Ve
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
.PP
.if n .I "\f(CW""directive""\fP"
.el .I "\f(CWdirective\fP"
.IX Subsection "directive"
.PP
.Vb 1
\& my $directive = $result->directive;
.Ve
If a \s-1SKIP\s0 directive is included with the plan, this method will return it.
.PP
.Vb 1
\& 1..0 # SKIP: why bother?
.Ve
.if n .I "\f(CW""explanation""\fP"
.el .I "\f(CWexplanation\fP"
.IX Subsection "explanation"
.PP
.Vb 1
\& my $explanation = $result->explanation;
.Ve
If a \s-1SKIP\s0 directive was included with the plan, this method will return the
explanation, if any.
.if n .Sh "\f(CW""pragma""\fP methods"
.el .Sh "\f(CWpragma\fP methods"
.IX Subsection "pragma methods"
.Vb 1
\& if ( $result->is_pragma ) { ... }
.Ve
If the above evaluates as true, the following methods will be available on the
\&\f(CW\*(C`$result\*(C'\fR object.
.PP
.if n .I "\f(CW""pragmas""\fP"
.el .I "\f(CWpragmas\fP"
.IX Subsection "pragmas"
.PP
Returns a list of pragmas each of which is a + or \- followed by the
pragma name.
.if n .Sh "\f(CW""comment""\fP methods"
.el .Sh "\f(CWcomment\fP methods"
.IX Subsection "comment methods"
.Vb 1
\& if ( $result->is_comment ) { ... }
.Ve
If the above evaluates as true, the following methods will be available on the
\&\f(CW\*(C`$result\*(C'\fR object.
.PP
.if n .I "\f(CW""comment""\fP"
.el .I "\f(CWcomment\fP"
.IX Subsection "comment"
.PP
.Vb 4
\&  if ( $result->is_comment ) {
\&      my $comment = $result->comment;
\&      print "I have something to say:  $comment";
\&  }
.Ve
.if n .Sh "\f(CW""bailout""\fP methods"
.el .Sh "\f(CWbailout\fP methods"
.IX Subsection "bailout methods"
.Vb 1
\& if ( $result->is_bailout ) { ... }
.Ve
If the above evaluates as true, the following methods will be available on the
\&\f(CW\*(C`$result\*(C'\fR object.
.PP
.if n .I "\f(CW""explanation""\fP"
.el .I "\f(CWexplanation\fP"
.IX Subsection "explanation"
.PP
.Vb 4
\&  if ( $result->is_bailout ) {
\&      my $explanation = $result->explanation;
\&      print "We bailed out because ($explanation)";
\&  }
.Ve
If, and only if, a token is a bailout token, you can get an \*(L"explanation\*(R" via
this method.  The explanation is the text after the mystical \*(L"Bail out!\*(R" words
which appear in the tap output.
.if n .Sh "\f(CW""unknown""\fP methods"
.el .Sh "\f(CWunknown\fP methods"
.IX Subsection "unknown methods"
.Vb 1
\& if ( $result->is_unknown ) { ... }
.Ve
There are no unique methods for unknown results.
.if n .Sh "\f(CW""test""\fP methods"
.el .Sh "\f(CWtest\fP methods"
.IX Subsection "test methods"
.Vb 1
\& if ( $result->is_test ) { ... }
.Ve
If the above evaluates as true, the following methods will be available on the
\&\f(CW\*(C`$result\*(C'\fR object.
.PP
.if n .I "\f(CW""ok""\fP"
.el .I "\f(CWok\fP"
.IX Subsection "ok"
.PP
.Vb 1
\&  my $ok = $result->ok;
.Ve
Returns the literal text of the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
.if n .I "\f(CW""number""\fP"
.el .I "\f(CWnumber\fP"
.IX Subsection "number"
.PP
.Vb 1
\&  my $test_number = $result->number;
.Ve
Returns the number of the test, even if the original \s-1TAP\s0 output did not supply
that number.
.PP
.if n .I "\f(CW""description""\fP"
.el .I "\f(CWdescription\fP"
.IX Subsection "description"
.PP
.Vb 1
\&  my $description = $result->description;
.Ve
Returns the description of the test, if any.  This is the portion after the
test number but before the directive.
.PP
.if n .I "\f(CW""directive""\fP"
.el .I "\f(CWdirective\fP"
.IX Subsection "directive"
.PP
.Vb 1
\&  my $directive = $result->directive;
.Ve
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directive was present for a test
line.
.PP
.if n .I "\f(CW""explanation""\fP"
.el .I "\f(CWexplanation\fP"
.IX Subsection "explanation"
.PP
.Vb 1
\&  my $explanation = $result->explanation;
.Ve
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, this method will return
the accompanying explanation, if present.
.PP
.Vb 1
\&  not ok 17 - 'Pigs can fly' # TODO not enough acid
.Ve
For the above line, the explanation is \fInot enough acid\fR.
.PP
.if n .I "\f(CW""is_ok""\fP"
.el .I "\f(CWis_ok\fP"
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result->is_ok ) { ... }
.Ve
Returns a boolean value indicating whether or not the test passed.  Remember
that for \s-1TODO\s0 tests, the test always passes.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`passed\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
.if n .I "\f(CW""is_actual_ok""\fP"
.el .I "\f(CWis_actual_ok\fP"
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result->is_actual_ok ) { ... }
.Ve
Returns a boolean value indicating whether or not the test passed, regardless
of its \s-1TODO\s0 status.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`actual_passed\*(C'\fR.  The latter method is deprecated
and will issue a warning.
.PP
.if n .I "\f(CW""is_unplanned""\fP"
.el .I "\f(CWis_unplanned\fP"
.IX Subsection "is_unplanned"
.PP
.Vb 1
\&  if ( $test->is_unplanned ) { ... }
.Ve
If a test number is greater than the number of planned tests, this method will
return true.  Unplanned tests will \fIalways\fR return false for \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not the test \f(CW\*(C`has_todo\*(C'\fR (see
the TAP::Parser::Result::Test manpage for more information about this).
.PP
.if n .I "\f(CW""has_skip""\fP"
.el .I "\f(CWhas_skip\fP"
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result->has_skip ) { ... }
.Ve
Returns a boolean value indicating whether or not this test had a \s-1SKIP\s0
directive.
.PP
.if n .I "\f(CW""has_todo""\fP"
.el .I "\f(CWhas_todo\fP"
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result->has_todo ) { ... }
.Ve
Returns a boolean value indicating whether or not this test had a \s-1TODO\s0
directive.
.PP
Note that \s-1TODO\s0 tests \fIalways\fR pass.  If you need to know whether or not
they really passed, check the \f(CW\*(C`is_actual_ok\*(C'\fR method.
.PP
.if n .I "\f(CW""in_todo""\fP"
.el .I "\f(CWin_todo\fP"
.IX Subsection "in_todo"
.PP
.Vb 1
\&  if ( $parser->in_todo ) { ... }
.Ve
True while the most recent result was a \s-1TODO\s0. Becomes true before the
\&\s-1TODO\s0 result is returned and stays true until just before the next non-
\&\s-1TODO\s0 test is returned.
.SH "TOTAL RESULTS"
.IX Header "TOTAL RESULTS"
After parsing the \s-1TAP\s0, there are many methods available to let you dig through
the results and determine what is meaningful to you.
.Sh "Individual Results"
.IX Subsection "Individual Results"
These results refer to individual tests which are run.
.PP
.if n .I "\f(CW""passed""\fP"
.el .I "\f(CWpassed\fP"
.IX Subsection "passed"
.PP
.Vb 2
\& my @passed = $parser->passed; # the test numbers which passed
\& my $passed = $parser->passed; # the number of tests which passed
.Ve
This method lets you know which (or how many) tests passed.  If a test failed
but had a \s-1TODO\s0 directive, it will be counted as a passed test.
.PP
.if n .I "\f(CW""failed""\fP"
.el .I "\f(CWfailed\fP"
.IX Subsection "failed"
.PP
.Vb 2
\& my @failed = $parser->failed; # the test numbers which failed
\& my $failed = $parser->failed; # the number of tests which failed
.Ve
This method lets you know which (or how many) tests failed.  If a test passed
but had a \s-1TODO\s0 directive, it will \fB\s-1NOT\s0\fR be counted as a failed test.
.PP
.if n .I "\f(CW""actual_passed""\fP"
.el .I "\f(CWactual_passed\fP"
.IX Subsection "actual_passed"
.PP
.Vb 2
\& # the test numbers which actually passed
\& my @actual_passed = $parser->actual_passed;
.Ve
.Vb 2
\& # the number of tests which actually passed
\& my $actual_passed = $parser->actual_passed;
.Ve
This method lets you know which (or how many) tests actually passed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
.if n .I "\f(CW""actual_ok""\fP"
.el .I "\f(CWactual_ok\fP"
.IX Subsection "actual_ok"
.PP
This method is a synonym for \f(CW\*(C`actual_passed\*(C'\fR.
.PP
.if n .I "\f(CW""actual_failed""\fP"
.el .I "\f(CWactual_failed\fP"
.IX Subsection "actual_failed"
.PP
.Vb 2
\& # the test numbers which actually failed
\& my @actual_failed = $parser->actual_failed;
.Ve
.Vb 2
\& # the number of tests which actually failed
\& my $actual_failed = $parser->actual_failed;
.Ve
This method lets you know which (or how many) tests actually failed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
.if n .I "\f(CW""todo""\fP"
.el .I "\f(CWtodo\fP"
.IX Subsection "todo"
.PP
.Vb 2
\& my @todo = $parser->todo; # the test numbers with todo directives
\& my $todo = $parser->todo; # the number of tests with todo directives
.Ve
This method lets you know which (or how many) tests had \s-1TODO\s0 directives.
.PP
.if n .I "\f(CW""todo_passed""\fP"
.el .I "\f(CWtodo_passed\fP"
.IX Subsection "todo_passed"
.PP
.Vb 2
\& # the test numbers which unexpectedly succeeded
\& my @todo_passed = $parser->todo_passed;
.Ve
.Vb 2
\& # the number of tests which unexpectedly succeeded
\& my $todo_passed = $parser->todo_passed;
.Ve
This method lets you know which (or how many) tests actually passed but were
declared as \*(L"\s-1TODO\s0\*(R" tests.
.PP
.if n .I "\f(CW""todo_failed""\fP"
.el .I "\f(CWtodo_failed\fP"
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.
.Ve
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
.if n .I "\f(CW""skipped""\fP"
.el .I "\f(CWskipped\fP"
.IX Subsection "skipped"
.PP
.Vb 2
\& my @skipped = $parser->skipped; # the test numbers with SKIP directives
\& my $skipped = $parser->skipped; # the number of tests with SKIP directives
.Ve
This method lets you know which (or how many) tests had \s-1SKIP\s0 directives.
.Sh "Pragmas"
.IX Subsection "Pragmas"
.if n .I "\f(CW""pragma""\fP"
.el .I "\f(CWpragma\fP"
.IX Subsection "pragma"
.PP
Get or set a pragma. To get the state of a pragma:
.PP
.Vb 3
\&  if ( $p->pragma('strict') ) {
\&      # be strict
\&  }
.Ve
To set the state of a pragma:
.PP
.Vb 1
\&  $p->pragma('strict', 1); # enable strict mode
.Ve
.if n .I "\f(CW""pragmas""\fP"
.el .I "\f(CWpragmas\fP"
.IX Subsection "pragmas"
.PP
Get a list of all the currently enabled pragmas:
.PP
.Vb 1
\&  my @pragmas_enabled = $p->pragmas;
.Ve
.Sh "Summary Results"
.IX Subsection "Summary Results"
These results are \*(L"meta\*(R" information about the total results of an individual
test program.
.PP
.if n .I "\f(CW""plan""\fP"
.el .I "\f(CWplan\fP"
.IX Subsection "plan"
.PP
.Vb 1
\& my $plan = $parser->plan;
.Ve
Returns the test plan, if found.
.PP
.if n .I "\f(CW""good_plan""\fP"
.el .I "\f(CWgood_plan\fP"
.IX Subsection "good_plan"
.PP
Deprecated.  Use \f(CW\*(C`is_good_plan\*(C'\fR instead.
.PP
.if n .I "\f(CW""is_good_plan""\fP"
.el .I "\f(CWis_good_plan\fP"
.IX Subsection "is_good_plan"
.PP
.Vb 1
\&  if ( $parser->is_good_plan ) { ... }
.Ve
Returns a boolean value indicating whether or not the number of tests planned
matches the number of tests run.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`good_plan\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
And since we're on that subject ...
.PP
.if n .I "\f(CW""tests_planned""\fP"
.el .I "\f(CWtests_planned\fP"
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  print $parser->tests_planned;
.Ve
Returns the number of tests planned, according to the plan.  For example, a
plan of '1..17' will mean that 17 tests were planned.
.PP
.if n .I "\f(CW""tests_run""\fP"
.el .I "\f(CWtests_run\fP"
.IX Subsection "tests_run"
.PP
.Vb 1
\&  print $parser->tests_run;
.Ve
Returns the number of tests which actually were run.  Hopefully this will
match the number of \f(CW\*(C`$parser\->tests_planned\*(C'\fR.
.PP
.if n .I "\f(CW""skip_all""\fP"
.el .I "\f(CWskip_all\fP"
.IX Subsection "skip_all"
.PP
Returns a true value (actually the reason for skipping) if all tests
were skipped.
.PP
.if n .I "\f(CW""start_time""\fP"
.el .I "\f(CWstart_time\fP"
.IX Subsection "start_time"
.PP
Returns the wall-clock time when the Parser was created.
.PP
.if n .I "\f(CW""end_time""\fP"
.el .I "\f(CWend_time\fP"
.IX Subsection "end_time"
.PP
Returns the wall-clock time when the end of \s-1TAP\s0 input was seen.
.PP
.if n .I "\f(CW""start_times""\fP"
.el .I "\f(CWstart_times\fP"
.IX Subsection "start_times"
.PP
Returns the \s-1CPU\s0 times (like the times entry in the perlfunc manpage when the Parser was created.
.PP
.if n .I "\f(CW""end_times""\fP"
.el .I "\f(CWend_times\fP"
.IX Subsection "end_times"
.PP
Returns the \s-1CPU\s0 times (like the times entry in the perlfunc manpage when the end of \s-1TAP\s0
input was seen.
.PP
.if n .I "\f(CW""has_problems""\fP"
.el .I "\f(CWhas_problems\fP"
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser->has_problems ) {
\&      ...
\&  }
.Ve
This is a 'catch-all' method which returns true if any tests have currently
failed, any \s-1TODO\s0 tests unexpectedly succeeded, or any parse errors occurred.
.PP
.if n .I "\f(CW""version""\fP"
.el .I "\f(CWversion\fP"
.IX Subsection "version"
.PP
.Vb 1
\&  $parser->version;
.Ve
Once the parser is done, this will return the version number for the
parsed \s-1TAP\s0. Version numbers were introduced with \s-1TAP\s0 version 13 so if no
version number is found version 12 is assumed.
.PP
.if n .I "\f(CW""exit""\fP"
.el .I "\f(CWexit\fP"
.IX Subsection "exit"
.PP
.Vb 1
\&  $parser->exit;
.Ve
Once the parser is done, this will return the exit status.  If the parser ran
an executable, it returns the exit status of the executable.
.PP
.if n .I "\f(CW""wait""\fP"
.el .I "\f(CWwait\fP"
.IX Subsection "wait"
.PP
.Vb 1
\&  $parser->wait;
.Ve
Once the parser is done, this will return the wait status.  If the parser ran
an executable, it returns the wait status of the executable.  Otherwise, this
merely returns the \f(CW\*(C`exit\*(C'\fR status.
.if n .Sh "\f(CW""ignore_exit""\fP"
.el .Sh "\f(CWignore_exit\fP"
.IX Subsection "ignore_exit"
.Vb 1
\&  $parser->ignore_exit(1);
.Ve
Tell the parser to ignore the exit status from the test when determining
whether the test passed. Normally tests with non-zero exit status are
considered to have failed even if all individual tests passed. In cases
where it is not possible to control the exit value of the test script
use this option to ignore it.
.PP
.if n .I "\f(CW""parse_errors""\fP"
.el .I "\f(CWparse_errors\fP"
.IX Subsection "parse_errors"
.PP
.Vb 2
\& my @errors = $parser->parse_errors; # the parser errors
\& my $errors = $parser->parse_errors; # the number of parser_errors
.Ve
Fortunately, all \s-1TAP\s0 output is perfect.  In the event that it is not, this
method will return parser errors.  Note that a junk line which the parser does
not recognize is \f(CW\*(C`not\*(C'\fR an error.  This allows this parser to handle future
versions of \s-1TAP\s0.  The following are all \s-1TAP\s0 errors reported by the parser:
.Ip "\(bu Misplaced plan" 4
.IX Item "Misplaced plan"
The plan (for example, '1..5'), must only come at the beginning or end of the
\&\s-1TAP\s0 output.
.Ip "\(bu No plan" 4
.IX Item "No plan"
Gotta have a plan!
.Ip "\(bu More than one plan" 4
.IX Item "More than one plan"
.Vb 5
\& 1..3
\& ok 1 - input file opened
\& not ok 2 - first line of the input valid # todo some data
\& ok 3 read the rest of the file
\& 1..3
.Ve
Right.  Very funny.  Don't do that.
.Ip "\(bu Test numbers out of sequence" 4
.IX Item "Test numbers out of sequence"
.Vb 4
\& 1..3
\& ok 1 - input file opened
\& not ok 2 - first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
That last test line above should have the number '3' instead of '2'.
.Sp
Note that it's perfectly acceptable for some lines to have test numbers and
others to not have them.  However, when a test number is found, it must be in
sequence.  The following is also an error:
.Sp
.Vb 4
\& 1..3
\& ok 1 - input file opened
\& not ok - first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
But this is not:
.Sp
.Vb 4
\& 1..3
\& ok  - input file opened
\& not ok - first line of the input valid # todo some data
\& ok 3 read the rest of the file
.Ve
.PP
.if n .I "\f(CW""get_select_handles""\fP"
.el .I "\f(CWget_select_handles\fP"
.IX Subsection "get_select_handles"
.PP
Get an a list of file handles which can be passed to \f(CW\*(C`select\*(C'\fR to
determine the readiness of this parser.
.PP
.if n .I "\f(CW""delete_spool""\fP"
.el .I "\f(CWdelete_spool\fP"
.IX Subsection "delete_spool"
.PP
Delete and return the spool.
.PP
.Vb 1
\&  my $fh = $parser->delete_spool;
.Ve
.SH "CALLBACKS"
.IX Header "CALLBACKS"
As mentioned earlier, a \*(L"callback\*(R" key may be added to the
\&\f(CW\*(C`TAP::Parser\*(C'\fR constructor. If present, each callback corresponding to a
given result type will be called with the result as the argument if the
\&\f(CW\*(C`run\*(C'\fR method is used. The callback is expected to be a subroutine
reference (or anonymous subroutine) which is invoked with the parser
result as its argument.
.PP
.Vb 7
\& my %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
.Ve
.Vb 11
\& my $aggregator = TAP::Parser::Aggregator->new;
\& for my $file ( @test_files ) {
\&     my $parser = TAP::Parser->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser->run;
\&     $aggregator->add( $file, $parser );
\& }
.Ve
Callbacks may also be added like this:
.PP
.Vb 2
\& $parser->callback( test => \e&test_callback );
\& $parser->callback( plan => \e&plan_callback );
.Ve
The following keys allowed for callbacks. These keys are case-sensitive.
.if n .Ip "\(bu \f(CW""""test""""\fR" 4
.el .Ip "\(bu \f(CWtest\fR" 4
.IX Item "test"
Invoked if \f(CW\*(C`$result\->is_test\*(C'\fR returns true.
.if n .Ip "\(bu \f(CW""""version""""\fR" 4
.el .Ip "\(bu \f(CWversion\fR" 4
.IX Item "version"
Invoked if \f(CW\*(C`$result\->is_version\*(C'\fR returns true.
.if n .Ip "\(bu \f(CW""""plan""""\fR" 4
.el .Ip "\(bu \f(CWplan\fR" 4
.IX Item "plan"
Invoked if \f(CW\*(C`$result\->is_plan\*(C'\fR returns true.
.if n .Ip "\(bu \f(CW""""comment""""\fR" 4
.el .Ip "\(bu \f(CWcomment\fR" 4
.IX Item "comment"
Invoked if \f(CW\*(C`$result\->is_comment\*(C'\fR returns true.
.if n .Ip "\(bu \f(CW""""bailout""""\fR" 4
.el .Ip "\(bu \f(CWbailout\fR" 4
.IX Item "bailout"
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.if n .Ip "\(bu \f(CW""""yaml""""\fR" 4
.el .Ip "\(bu \f(CWyaml\fR" 4
.IX Item "yaml"
Invoked if \f(CW\*(C`$result\->is_yaml\*(C'\fR returns true.
.if n .Ip "\(bu \f(CW""""unknown""""\fR" 4
.el .Ip "\(bu \f(CWunknown\fR" 4
.IX Item "unknown"
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.if n .Ip "\(bu \f(CW""""ELSE""""\fR" 4
.el .Ip "\(bu \f(CWELSE\fR" 4
.IX Item "ELSE"
If a result does not have a callback defined for it, this callback will
be invoked. Thus, if all of the previous result types are specified as
callbacks, this callback will \fInever\fR be invoked.
.if n .Ip "\(bu \f(CW""""ALL""""\fR" 4
.el .Ip "\(bu \f(CWALL\fR" 4
.IX Item "ALL"
This callback will always be invoked and this will happen for each
result after one of the above callbacks is invoked.  For example, if
the Term::ANSIColor manpage is loaded, you could use the following to color your
test output:
.Sp
.Vb 12
\& my %callbacks = (
\&     test => sub {
\&         my $test = shift;
\&         if ( $test->is_ok && not $test->directive ) {
\&             # normal passing test
\&             print color 'green';
\&         }
\&         elsif ( !$test->is_ok ) {    # even if it's TODO
\&             print color 'white on_red';
\&         }
\&         elsif ( $test->has_skip ) {
\&             print color 'white on_blue';
.Ve
.Vb 16
\&         }
\&         elsif ( $test->has_todo ) {
\&             print color 'white';
\&         }
\&     },
\&     ELSE => sub {
\&         # plan, comment, and so on (anything which isn't a test line)
\&         print color 'black on_white';
\&     },
\&     ALL => sub {
\&         # now print them
\&         print shift->as_string;
\&         print color 'reset';
\&         print "\en";
\&     },
\& );
.Ve
.if n .Ip "\(bu \f(CW""""EOF""""\fR" 4
.el .Ip "\(bu \f(CWEOF\fR" 4
.IX Item "EOF"
Invoked when there are no more lines to be parsed. Since there is no
accompanying the TAP::Parser::Result manpage object the \f(CW\*(C`TAP::Parser\*(C'\fR object is
passed instead.
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
If you're looking for an \s-1EBNF\s0 grammar, see the TAP::Parser::Grammar manpage.
.SH "BACKWARDS COMPATIBILITY"
.IX Header "BACKWARDS COMPATIBILITY"
The Perl-QA list attempted to ensure backwards compatibility with
the Test::Harness manpage.  However, there are some minor differences.
.Sh "Differences"
.IX Subsection "Differences"
.Ip "\(bu \s-1TODO\s0 plans" 4
.IX Item "TODO plans"
A little-known feature of the Test::Harness manpage is that it supported \s-1TODO\s0
lists in the plan:
.Sp
.Vb 3
\& 1..2 todo 2
\& ok 1 - We have liftoff
\& not ok 2 - Anti-gravity device activated
.Ve
Under the Test::Harness manpage, test number 2 would \fIpass\fR because it was
listed as a \s-1TODO\s0 test on the plan line. However, we are not aware of
anyone actually using this feature and hard-coding test numbers is
discouraged because it's very easy to add a test and break the test
number sequence. This makes test suites very fragile. Instead, the
following should be used:
.Sp
.Vb 3
\& 1..2
\& ok 1 - We have liftoff
\& not ok 2 - Anti-gravity device activated # TODO
.Ve
.Ip "\(bu 'Missing' tests" 4
.IX Item "'Missing' tests"
It rarely happens, but sometimes a harness might encounter
\&'missing tests:
.Sp
.Vb 5
\& ok 1
\& ok 2
\& ok 15
\& ok 16
\& ok 17
.Ve
the Test::Harness manpage would report tests 3\-14 as having failed. For the
\&\f(CW\*(C`TAP::Parser\*(C'\fR, these tests are not considered failed because they've
never run. They're reported as parse failures (tests out of sequence).
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If you find you need to provide custom functionality (as you would have using
the Test::Harness::Straps manpage), you're in luck: \f(CW\*(C`TAP::Parser\*(C'\fR and friends are
designed to be easily plugged-into and/or subclassed.
.PP
Before you start, it's important to know a few things:
.Ip "1" 2
.IX Item "1"
All \f(CW\*(C`TAP::*\*(C'\fR objects inherit from the TAP::Object manpage.
.Ip "2" 2
.IX Item "2"
Many \f(CW\*(C`TAP::*\*(C'\fR classes have a \fI\s-1SUBCLASSING\s0\fR section to guide you.
.Ip "3" 2
.IX Item "3"
Note that \f(CW\*(C`TAP::Parser\*(C'\fR is designed to be the central \*(L"maker\*(R" \- ie: it is
responsible for creating most new objects in the \f(CW\*(C`TAP::Parser::*\*(C'\fR namespace.
.Sp
This makes it possible for you to have a single point of configuring what
subclasses should be used, which means that in many cases you'll find
you only need to sub-class one of the parser's components.
.Sp
The exception to this rule are \fISourceHandlers\fR & \fIIterators\fR, but those are
both created with customizable \fIIteratorFactory\fR.
.Ip "4" 2
.IX Item "4"
By subclassing, you may end up overriding undocumented methods.  That's not
a bad thing per se, but be forewarned that undocumented methods may change
without warning from one release to the next \- we cannot guarantee backwards
compatibility.  If any \fIdocumented\fR method needs changing, it will be
deprecated first, and changed in a later release.
.Sh "Parser Components"
.IX Subsection "Parser Components"
.I "Sources"
.IX Subsection "Sources"
.PP
A \s-1TAP\s0 parser consumes input from a single \fIraw source\fR of \s-1TAP\s0, which could come
from anywhere (a file, an executable, a database, an \s-1IO\s0 handle, a \s-1URI\s0, etc..).
The source gets bundled up in a the TAP::Parser::Source manpage object which gathers some
meta data about it.  The parser then uses a the TAP::Parser::IteratorFactory manpage to
determine which the TAP::Parser::SourceHandler manpage to use to turn the raw source
into a stream of \s-1TAP\s0 by way of the Iterators entry elsewhere in this document.
.PP
If you simply want \f(CW\*(C`TAP::Parser\*(C'\fR to handle a new source of \s-1TAP\s0 you probably
don't need to subclass \f(CW\*(C`TAP::Parser\*(C'\fR itself.  Rather, you'll need to create a
new the TAP::Parser::SourceHandler manpage class, and just plug it into the parser using
the \fIsources\fR param to the new entry elsewhere in this document.  Before you start writing one, read through
the TAP::Parser::IteratorFactory manpage to get a feel for how the system works first.
.PP
If you find you really need to use your own iterator factory you can still do
so without sub-classing \f(CW\*(C`TAP::Parser\*(C'\fR by setting the iterator_factory_class entry elsewhere in this document.
.PP
If you just need to customize the objects on creation, subclass the TAP::Parser manpage
and override the make_iterator_factory entry elsewhere in this document.
.PP
Note that \f(CW\*(C`make_source\*(C'\fR & \f(CW\*(C`make_perl_source\*(C'\fR have been \fI\s-1DEPRECATED\s0\fR and
are now removed.
.PP
.I "Iterators"
.IX Subsection "Iterators"
.PP
A \s-1TAP\s0 parser uses \fIiterators\fR to loop through the \fIstream\fR of \s-1TAP\s0 read in
from the \fIsource\fR it was given.  There are a few types of Iterators available
by default, all sub-classes of the TAP::Parser::Iterator manpage.  Choosing which
iterator to use is the responsibility of the \fIiterator factory\fR, though it
simply delegates to the \fISource Handler\fR it uses.
.PP
If you're writing your own the TAP::Parser::SourceHandler manpage, you may need to
create your own iterators too.  If so you'll need to subclass
the TAP::Parser::Iterator manpage.
.PP
Note that the make_iterator entry elsewhere in this document has been \fI\s-1DEPRECATED\s0\fR and is now removed.
.PP
.I "Results"
.IX Subsection "Results"
.PP
A \s-1TAP\s0 parser creates the TAP::Parser::Result manpages as it iterates through the
input \fIstream\fR.  There are quite a few result types available; choosing
which class to use is the responsibility of the \fIresult factory\fR.
.PP
To create your own result types you have two options:
.Ip "option 1" 2
.IX Item "option 1"
Subclass the TAP::Parser::Result manpage and register your new result type/class with
the default the TAP::Parser::ResultFactory manpage.
.Ip "option 2" 2
.IX Item "option 2"
Subclass the TAP::Parser::ResultFactory manpage itself and implement your own
the TAP::Parser::Result manpage creation logic.  Then you'll need to customize the
class used by your parser by setting the \f(CW\*(C`result_factory_class\*(C'\fR parameter.
See the new entry elsewhere in this document for more details.
.PP
If you need to customize the objects on creation, subclass the TAP::Parser manpage and
override the make_result entry elsewhere in this document.
.PP
.I "Grammar"
.IX Subsection "Grammar"
.PP
the TAP::Parser::Grammar manpage is the heart of the parser.  It tokenizes the \s-1TAP\s0
input \fIstream\fR and produces results.  If you need to customize its behaviour
you should probably familiarize yourself with the source first.  Enough
lecturing.
.PP
Subclass the TAP::Parser::Grammar manpage and customize your parser by setting the
\&\f(CW\*(C`grammar_class\*(C'\fR parameter.  See the new entry elsewhere in this document for more details.
.PP
If you need to customize the objects on creation, subclass the TAP::Parser manpage and
override the make_grammar entry elsewhere in this document
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
All of the following have helped. Bug reports, patches, (im)moral
support, or just words of encouragement have all been forthcoming.
.Ip "\(bu Michael Schwern" 4
.IX Item "Michael Schwern"
.PD 0
.Ip "\(bu Andy Lester" 4
.IX Item "Andy Lester"
.Ip "\(bu chromatic" 4
.IX Item "chromatic"
.Ip "\(bu \s-1GEOFFR\s0" 4
.IX Item "GEOFFR"
.Ip "\(bu Shlomi Fish" 4
.IX Item "Shlomi Fish"
.Ip "\(bu Torsten Schoenfeld" 4
.IX Item "Torsten Schoenfeld"
.Ip "\(bu Jerry Gay" 4
.IX Item "Jerry Gay"
.Ip "\(bu Aristotle" 4
.IX Item "Aristotle"
.Ip "\(bu Adam Kennedy" 4
.IX Item "Adam Kennedy"
.Ip "\(bu Yves Orton" 4
.IX Item "Yves Orton"
.Ip "\(bu Adrian Howard" 4
.IX Item "Adrian Howard"
.Ip "\(bu Sean & Lil" 4
.IX Item "Sean & Lil"
.Ip "\(bu Andreas J. Koenig" 4
.IX Item "Andreas J. Koenig"
.Ip "\(bu Florian Ragwitz" 4
.IX Item "Florian Ragwitz"
.Ip "\(bu Corion" 4
.IX Item "Corion"
.Ip "\(bu Mark Stosberg" 4
.IX Item "Mark Stosberg"
.Ip "\(bu Matt Kraai" 4
.IX Item "Matt Kraai"
.Ip "\(bu David Wheeler" 4
.IX Item "David Wheeler"
.Ip "\(bu Alex Vandiver" 4
.IX Item "Alex Vandiver"
.Ip "\(bu Cosimo Streppone" 4
.IX Item "Cosimo Streppone"
.Ip "\(bu Ville Skyttä" 4
.IX Item "Ville Skyttä"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.PP
Andy Armstong <andy@hexten.net>
.PP
Eric Wilhelm @ <ewilhelm at cpan dot org>
.PP
Michael Peters <mpeters at plusthree dot com>
.PP
Leif Eriksen <leif dot eriksen at bigpond dot com>
.PP
Steve Purkis <spurkis@cpan.org>
.PP
Nicholas Clark <nick@ccl4.org>
.PP
Lee Johnson <notfadeaway at btinternet dot com>
.PP
Philippe Bruhat <book@cpan.org>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-test\-harness@rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness.
We will be notified, and then you'll automatically be notified of
progress on your bug as we make changes.
.PP
Obviously, bugs which include patches are best. If you prefer, you can
patch against bleed by via anonymous checkout of the latest version:
.PP
.Vb 1
\& git clone git://github.com/Perl-Toolchain-Gang/Test-Harness.git
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2008 Curtis \*(L"Ovid\*(R" Poe, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
